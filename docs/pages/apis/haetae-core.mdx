import Callout from 'nextra-theme-docs/callout'
import { Chip } from '@mui/material';
import PkgManagerTabs from '../../components/PkgManagerTabs'
import Type from '../../components/TypeOnHeadSide'

# `@haetae/core`

`@haetae/core` provides every core feature for Haetae.<br/>
For instance, it handles config file, store file, and your command's `env` and `run`.<br/>
If you want to use Haetae by programatic api, you probably need this package.

## Used by

**Note**: This is not exhaustive and lists only Haetae's packages.

- [`haetae/utils`](./haetae-utils)
- [`haetae/javascript`](./haetae-javascript)
- [`haetae/git`](./haetae-git)
- [`haetae/cli`](./haetae-cli)
- [`haetae`](./haetae)

## Installation

Unlike other `@haetae/*` packages, `@haetae/core` doesn't have `peerDependencies`.
Just purely installing `@haetae/core` itself is enough.

<Callout>
  **Are you developing a library(e.g. plugin) for Haetae?** <br />
  It might be more suitable to specify `@haetae/core` as `peerDependencies` than `dependencies`.
</Callout>

<br/>

<PkgManagerTabs>
  <>
    ```bash
    # As dependencies
    npm install @haetae/core
    # As devDependencies
    npm install --save-dev @haetae/core
    ```
  </>
  <>
    ```bash
    # As dependencies
    yarn add @haetae/core
    # As devDependencies
    yarn add --dev @haetae/core
    ```
  </>
  <>
    ```bash
    # As dependencies
    pnpm add @haetae/core
    # As devDependencies
    pnpm add --save-dev @haetae/core
    ```
  </>
</PkgManagerTabs>

## API

### Utility type

Some APIs depends on an utility type named `PromiseOr`.

```ts
type PromiseOr<T> = Promise<T> | T
```

`@haetae/core` does not export this, but you'd better know this.

### Memoization

[Memoization](https://en.wikipedia.org/wiki/Memoization) is a technique returning the cached result.
Some functions (e.g. `getConfig`, `getStore`) are memoized.

<Callout>
Memoized functions have tag chip beside their name: <Chip label="memoized" color="primary" size="small" variant="outlined" component="a" href="#memoization" clickable />
</Callout>

#### Cache hit and clear

To clear memoization cache, you can call `<function>.clear()`.
For example, `getConfig` is a memoized function, and `getConfig.clear()` would clear its cache.

```ts
const { getConfig } = require('@haetae/core')

// `getConfig` is executed.
const config1 = await getConfig({ filename: '/foo/haetae.config.js' })

// `getConfig` is executed. No memoization cache hit, due to different argument.
const config2 = await getConfig({ filename: '/bar/haetae.config.js' })

// Cache hit from the 1st call result, thanks to the same argument.
// `getConfig` is not executed. Just returned from the memoization cache.
const config3 = await getConfig({ filename: '/foo/haetae.config.js' })

// Cache hit from the 2nd call result, thanks to the same argument.
const config4 = await getConfig({ filename: '/bar/haetae.config.js' })

// Clear the memoization cache entirely
getConfig.clear()

// `getConfig` is freshly executed without cache.
// A new cache is created from now on again.
const config5 = await getConfig({ filename: '/foo/haetae.config.js' })
```

#### Cache is by shallow copy

Memoization cache is based on shallow copy.

```ts
// `config1` and `config2` would have same memory address.
const config1 = await getConfig()
const config2 = await getConfig()

config1.foo = 'bar'
// config2 is also modified when config1 is modified
console.log(config2.foo) // 'bar'
```

If you want to avoid the side effect, you can clear cache before calling `getConfig`.<br/>
Or deep copy techniques like [immer](https://github.com/immerjs/immer) can be a good solution.

### Type notations

Annotating typescript types by default.<br/>
Note that trailing `?` means an optional field.

### `pkg`

Refer to `pkg` in [**apis/common**](./common).

### `setCurrentCommand` : <Type>`(command: string) => void`</Type>

A setter for current command name, which is a module-level state.<br/>
Set it before calling other APIs that requires it.

### `getCurrentCommand` : <Type>`() => string`</Type>

A getter for current command name, which is a module-level state.

### `defaultConfigFile` : <Type>`"haetae.config.js"`</Type>

A string constant for default config file name.<br/>
This is used when config file path is not given or given as a directory.

### `setConfigFilename` : <Type>`(command: string) => void`</Type>

A setter for config file name, which is a module-level state.<br/>
Set it before calling other APIs that requires a config file.

### `getConfigFilename` : <Type>`() => string`</Type>

A getter for config file name, which is a module-level state.

### `getConfigDirname` : <Type>`() => string`</Type>

A getter for config file's directory name, which is a derived module-level state.

### `defaultStoreFilename` : <Type>`".haetae/store.js"`</Type>

A string constant for default store file name.<br/>
This is used when `storeFile` is not given, or given as a directory.

### `setStoreFilename` : <Type>`(command: string) => void`</Type>

A setter for store file name, which is a module-level state.<br/>
Set it before calling other APIs that requires it.

### `getStoreFilename` : <Type>`() => string`</Type>

A getter for store file name, which is a module-level state.<br/>

### `HaetaeRecord`

```ts
interface HaetaeRecord<D = unknown, E = unknown> {
  data: D | null
  env: E | null
  time: number
}
```

### `HaetaeStore`

```ts
interface HaetaeStore<D = unknown, E = unknown> {
  version: string
  commands: {
    [command: string]: HaetaeRecord<D, E>[]
  }
}
```

### `HaetaeCommandEnv`

```ts
type HaetaeCommandEnv<E = unknown> = () => void | PromiseOr<
  E | null | undefined
>
```

### `HaetaePreCommandEnv`

```ts
type HaetaePreCommandEnv<E = unknown> =
  | HaetaeCommandEnv<E>
  | PromiseOr<E | null | undefined>
```

### `HaetaePreCommand`

```ts
interface HaetaePreCommand<D = unknown, E = unknown> {
  run: () => void | PromiseOr<D | null | undefined>
  env?: HaetaePreCommandEnv<E>
}
```

### `HaetaeCommand`

```ts
interface HaetaeCommand<D = unknown, E = unknown> {
  run: () => void | PromiseOr<D | null | undefined>
  env: HaetaeCommandEnv<E>
}
```

### `RootEnv`

```ts
type RootEnv<E = unknown> = (
  envFromCommand: E | null,
) => PromiseOr<E | null>
```

### `RootRecordData`

```ts
type RootRecordData<D = unknown> = (
  recordDataFromCommand: D | null,
) => PromiseOr<D | null>

```

### `HaetaePreConfig`

An interface of user-given config schema.<br/>
Also an argument interface of function `configure`.

```ts
interface HaetaePreConfig<D = unknown, E = unknown> {
  commands: {
    [command: string]: HaetaePreCommand<D, E>
  }
  env?: RootEnv<E>
  recordData?: RootRecordData<D>
  recordRemoval?: {
    age?: string | number
    count?: number
  }
  storeFile?: string
}
```

### `HaetaeConfig`

An interface of normalized config schema.<br/>
Also a return type of function `configure`.

```ts
interface HaetaeConfig<D = unknown, E = unknown> {
  commands: {
    [command: string]: HaetaeCommand<D, E>
  }
  env: RootEnv<E>
  recordData: RootRecordData<D>
  recordRemoval: {
    age: number
    count: number
  }
  storeFile: string
}
```

### `configure` : <Type>`<D = unknown, E = unknown>(options: HaetaePreConfig<D, E>) => HaetaeConfig<D, E>`</Type>

Users write config file `haetae.config.json` by themselves.
`configure` validates and transform the user-provided config into normalized config.

**Options**

- `commands` : Your commands as an object.
- `env?` : An env-to-env mapper/transformer. <small>(default: `(arg) => arg`)</small>
- `recordData?` : An recordData-to-recordData mapper/transformer. <small>(default: `(arg) => arg`)</small>
- `recordRemoval.age?`: Age threshold by milliseconds. Records whose age are older than this value are to be removed when calling `addRecord`.
- `recordRemoval.count?`: The number of total records to keep. When the number of records becomes larger than this value, old records are removed to satisfy the threshold when calling `addRecord`. This task is executed after that of `recordRemoval.age`.
- `storeFile?` : A store file path. <small>(default: `"."`)</small>


#### Type-check for your config

**haetae.config.js**:

This is 100% valid.
But you'd not get type-check from the IDE.

```js
module.exports = { /* ... */ }
```

With `configure`, type-check is enabled in your IDE! Happy ðŸ˜Š

```js
const { core } = require('haetae')

module.exports = core.configure({ /* ... */ })
```

#### Normalization

Schema of return value(`HaetaeConfig`) is ***roughly*** similar to that of the passed `options` argument(`HaetaePreConfig`).
The return value is a normalized result of user-given config.

- Omitted options on user-given config are to be set as their default values.
- `storeFile` is transformed as an absolute path, when given as a releative path.
- `storeFile` is normalized as a path whose delimiter is `/`. <small>(Note: this is perfectly fine and even recommended on Windows nodejs runtime.)</small>
- `storeFile` is transformed as a file path, when given as a directory (non-json extension) path. `defaultConfigFile` is used for that purpose. For example, `/path/to/config` becomes `/path/to/config/haetae.config.json`.

<Callout>
**`configure` is an idempotent function**. <br/>
For example, `configure(obj) == configure(configure(obj))`.
</Callout>

### `GetConfigOptions`

An argument interface of function `getConfig`.

```ts
interface GetConfigOptions {
  filename?: PromiseOr<string> // It should be an absolute path
}
```

### `getConfig` : <Type>`<D = unknown, E = unknown>(options?: GetConfigOptions) => Promise<HaetaeConfig<D, E>>`</Type> <Chip label="memoized" color="primary" size="small" variant="outlined" component="a" href="#memoization" clickable />

A function to get config object by config file path.

**Options?**

- `filename?` : An **absolute** path to config file. <small>(default: `getConfigFilename()`)</small>

### `initNewStore` : <Type>`<D = unknown, E = unknown>() => HaetaeStore<D, E>`</Type>

Initializes an empty store. It just returns an object. It does not save it as a file.

### `GetStoreOptions`

An argument interface of function `getStore`.

```ts
interface GetStoreOptions<D = unknown, E = unknown>
  extends FilenameOption {
  fallback?: ({
    filename,
    error,
  }: {
    filename: string
    error: Error
  }) => PromiseOr<HaetaeStore<D, E>> | never
}
```

### `getStore` : <Type>`<D = unknown, E = unknown>(options?: GetStoreOptions<D, E>) => Promise<HaetaeStore<D, E>>`</Type> <Chip label="memoized" color="primary" size="small" variant="outlined" component="a" href="#memoization" clickable />

A function to get store object.

**Options?**

- `filename?` : A path to store file (e.g. `/path/to/.haetae/store.json`). <small>(default: `getStoreFilename()`)</small>
- `fallback?` : A function to generate an alternative return value, when `filename` is a non-existent file. `fallback` can be useful if you want to throw an error (e.g. `({error}) => { throw error }`) rather than get a new store object from `initNewStore` by default. <small>(default: `initNewStore`)</small>


### `GetRecordsOptions`

An argument interface of function `getRecords`.

```ts
interface GetRecordsOptions<D = unknown, E = unknown> {
  command?: PromiseOr<string>
  store?: PromiseOr<HaetaeStore<D, E>>
}
```

### `getRecords` : <Type>`<D = unknown, E = unknown>(options?: GetRecordsOptions<D, E>) => Promise<HaetaeRecord<D, E>[] | undefined> `</Type>

A function to get records of a given command from given store.

<Callout>
There're `getRecords` (plural) and `getRecord` (singular). Don't confuse!
</Callout>

**Options?**

- `command?` : A command name to get records of. <small>(default: `getCurrentCommand()`)</small>
- `store?` : A store object. <small>(default: `getStore()`)</small>


### `CommandFromConfig`

An argument interface of function `invokeEnv` and `invokeRun`.

```ts
interface CommandFromConfig<D = unknown, E = unknown> {
  command?: PromiseOr<string>
  config?: PromiseOr<HaetaeConfig<D, E>>
}
```

### `invokeEnv` : <Type>`<E = unknown>(options?: CommandFromConfig<unknown, E>) => Promise<E | null>`</Type> <Chip label="memoized" color="primary" size="small" variant="outlined" component="a" href="#memoization" clickable />

A function to invoke(execute) user-defined `env` of the given `command`.

**Options?**

- `command?` : A command name to invoke `env` of. <small>(default: `getCurrentCommand()`)</small>
- `config?` : A config object. <small>(default: `getConfig()`)</small>


### `invokeRun` : <Type>`<D = unknown>(options?: CommandFromConfig<D, unknown>) => Promise<D | null>`</Type>

A function to invoke(execute) user-defined `run` of the given `command`.

**Options?**

- `command?` : A command name to invoke `env` of. <small>(default: `getCurrentCommand()`)</small>
- `config?` : A config object. <small>(default: `getConfig()`)</small>

### `GetRecordOptions`

An argument interface of a function `getRecord`.

```ts
interface GetRecordOptions<D = unknown, E = unknown>
  extends GetRecordsOptions<D, E> {
  env?: PromiseOr<E | null>
}
```

### `compareEnvs` : <Type>`(one: unknown, theOther: unknown): boolean`</Type>

A function to compare two resolved env object.<br/>
Returns `true` if they're equal, `false` otherwise.

**Arguments**

- `one` : A resolved env object to compare with `theOther`.
- `theOther` : A resolved env object to compare with `one`.

### `getRecord` : <Type>`<D = unknown, E = unknown>(options?: GetRecordOptions<D, E>) => Promise<HaetaeRecord<D, E> | undefined>`</Type>

A function to get a record of a given command from given store, corresponding to the given env.

<Callout>
There're `getRecords` (plural) and `getRecord` (singular). Don't confuse!
</Callout>

**Options?**

- `command?` : A command name to get records of. <small>(default: `getCurrentCommand()`)</small>
- `store?` : A store object. <small>(default: `getStore()`)</small>
- `env?` : A resolved env object. <small>(default: `invokeEnv({ command })`)</small>


### `FormRecordOptions`

An argument interface of function `formRecord`.

```ts
interface FormRecordOptions<D = unknown, E = unknown> {
  data?: PromiseOr<D | null>
  env?: PromiseOr<E | null>
  time?: number
}
```

### `formRecord` : <Type>`<D = unknown, E = unknown>(options?: FormRecordOptions<D, E>) => Promise<HaetaeRecord<D, E>>`</Type>

A function to create a new record object.<br/>
This only returns an object, not save it.

**Options?**

- `data?` : A record data. <small>(default: `invokeRun()`)</small>
- `env?` : A resolved env object. <small>(default: `invokeEnv()`)</small>
- `time?` : [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) by milliseconds. <small>(default: `Date.now()`)</small>


### `AddRecordOptions`

An argument interface of function `addRecord`.

```ts
interface AddRecordOptions<D = unknown, E = unknown> {
  config?: PromiseOr<HaetaeConfig>
  command?: PromiseOr<string>
  store?: PromiseOr<HaetaeStore<D, E>>
  record?: PromiseOr<HaetaeRecord<D, E>>
}
```

### `addRecord` : <Type>`<D = unknown, E = unknown>(options?: AddRecordOptions<D, E>) => Promise<HaetaeStore<D, E>>`</Type>

A function to add a new record under the given command to store.

**Options?**

- `config?` : A config object. <small>(default: `getConfig()`)</small>
  - `config.recordRemoval.age`: Age threshold by milliseconds. Records whose age are older than this value are removed.
  - `config.recordRemoval.count`: The number of total records to keep. When the number of records becomes larger than this value, old records are removed to satisfy the threshold. This task is executed after that of `config.recordRemoval.age`.
- `command?` : A command name to add record under. <small>(default: `getCurrentCommand()`)</small>
- `store?` : A store object. <small>(default: `getStore()`)</small>
- `record?` : A new record object to add. <small>(default: `formRecord({ data: invokeRun({ command }), env: invokeEnv({ command }) })`)</small>

### `SaveStoreOptions`

An argument interface of function `saveStore`.

```ts
interface SaveStoreOptions extends FilenameOption {
  store?: PromiseOr<HaetaeStore>
}
```

### `saveStore` : <Type>`(options?: SaveStoreOptions) => Promise<void>`</Type>

A function to save store object to file.<br/>
Memoization cache of `getStore` would be clear automatically.<br/>
File IO and Memoization cache clear is done sequentially in synchronous manner, as a transaction.

**Options?**

- `filename?` : A file path to write store on. <small>(default: `getStoreFilename()`)</small>
- `store?` : A store object to save. <small>(default: `mapStore()`)</small>

### `deleteStore` : <Type>`(options?: FilenameOption) => Promise<void>`</Type>

A function to delete the entire store by removing the store file.<br/>
Memoization cache of `getStore` would be clear automatically.<br/>
File IO and Memoization cache clear is done sequentially in synchronous manner, as a transaction.

**Options?**

- `filename?` : A store file path to delete. <small>(default: `getStoreFilename()`)</small>
